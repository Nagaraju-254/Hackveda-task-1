# -*- coding: utf-8 -*-
"""GoogleCrawler.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fuEq0tiwjoor5Gw1mY7NeYmR4Qf1l74j
"""

import requests
import json
import pandas as pd
from datetime import datetime

# Ask the user for a keyword
keyword = input("Enter the keyword:")
keyword1=keyword
# List of sites to search in
site_list = {"quora.com", "geeksforgeeks.com","google.com"}
titles = []
links = []
# Your API key and Custom Search Engine ID
api_key = "AIzaSyB4ztSm0Q7cTtDQnd5DdVGh_WXuXbUgQsQ"
cx = "56e2057e5f22a4ded"

for site in site_list:
    # Construct search query
    search_query = f"{keyword} site:{site}"
    print(f"Searching for: {search_query}")

    # Construct Google Custom Search API URL
    google_url = f"https://www.googleapis.com/customsearch/v1?key={api_key}&cx={cx}&q={search_query}"

    # Send request to Google
    response = requests.get(google_url)

    # Check if the response status is OK
    if response.status_code == 200:
        # Parse JSON response
        data = json.loads(response.text)
        total_results = int(data["searchInformation"]["totalResults"])

    # Get the start index of the next page if it exists
        if 'nextPage' in data['queries']:
            next_Index = data['queries']['nextPage'][0]['startIndex']
        else:
            next_Index = None  # Handle the case when there is no next page
        # Check if 'items' key is in the response
        if 'items' in data:
            for item in data['items']:
                title = item['title']
                link = item['link']
                titles.append(title)
                links.append(link)
        else:
            print(f"No items found for {search_query}")
    else:
        print(f"Error: {response.status_code}, {response.text}")
    keyword=keyword1
    # Handle error

# Debug: Print the collected titles and links
print(f"Titles: {titles}")
print(f"Links: {links}")

# Create a dictionary from the lists
data_dict = {
    'Title': titles,
    'Link': links
}

# Create a DataFrame from the dictionary
df = pd.DataFrame(data_dict)

# Debug: Print the DataFrame to check the contents
print("\nDataFrame:")
print(df)

# Save the DataFrame to a CSV file
csv_filename = "search_results.csv"
df.to_csv(csv_filename, index=False)
print(f"Saved search results to {csv_filename}")

from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
import smtplib
import os

# Initialize connection to our email server, we will use Gmail here
smtp = smtplib.SMTP('smtp.gmail.com', 587)
smtp.ehlo()
smtp.starttls()

# Login with your email and password
smtp.login('nagarajunangunuri254@gmail.com', 'ddul gcug rzgl dibv')

# Send our email message 'msg' to our boss
def message(subject="Python Notification", text="", img=None, attachment=None):
    # Build message contents
    msg = MIMEMultipart()

    # Add Subject
    msg['Subject'] = subject

    # Add text contents
    msg.attach(MIMEText(text))

    # Check if we have anything given in the img parameter
    if img is not None:
        # Check whether we have the lists of images or not!
        if type(img) is not list:
            # If it isn't a list, make it one
            img = [img]

        # Now iterate through our list
        for one_img in img:
            # Read the image binary data
            with open(one_img, 'rb') as f:
                img_data = f.read()
            # Attach the image data to MIMEMultipart using MIMEImage, we add the given filename using os.path.basename
            msg.attach(MIMEImage(img_data, name=os.path.basename(one_img)))

    # We do the same for attachments as we did for images
    if attachment is not None:
        # Check whether we have the lists of attachments or not!
        if type(attachment) is not list:
            # If it isn't a list, make it one
            attachment = [attachment]

        for one_attachment in attachment:
            with open(one_attachment, 'rb') as f:
                # Read in the attachment using MIMEApplication
                file = MIMEApplication(f.read(), name=os.path.basename(one_attachment))
            file['Content-Disposition'] = f'attachment; filename="{os.path.basename(one_attachment)}"'

            # At last, add the attachment to our message object
            msg.attach(file)

    return msg

# Paths to the image and PDF files
img_path = r"/content/Nagapic.jpg"
pdf_path = r"/content/Nagaraju Resume.pdf"

# Debug prints
print("Image path:", img_path)
print("Image file exists:", os.path.exists(img_path))
print("PDF path:", pdf_path)
print("PDF file exists:", os.path.exists(pdf_path))

# If the files exist, proceed with sending the email
if os.path.exists(img_path) and os.path.exists(pdf_path):
    # Call the message function with the PDF as an attachment
    msg = message("Good!", "Hi there!", img=img_path, attachment=pdf_path)

    # Make a list of emails, where you wanna send mail
    to = ["2103a51136@sru.edu.in", "nagavirat243@gmail.com"]

    # Provide some data to the sendmail function
    smtp.sendmail(from_addr="nagarajunangunuri254@gmail.com", to_addrs=to, msg=msg.as_string())

    # Finally, don't forget to close the connection
    smtp.quit()
else:
    if not os.path.exists(img_path):
        print("Image file not found. Please check the file path and try again.")
    if not os.path.exists(pdf_path):
        print("PDF file not found. Please check the file path and try again.")